<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面试 | 笔记</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="笔记">
    
    <link rel="preload" href="/benisarookie/assets/css/0.styles.5cdbf686.css" as="style"><link rel="preload" href="/benisarookie/assets/js/app.b911dc94.js" as="script"><link rel="preload" href="/benisarookie/assets/js/2.d4767806.js" as="script"><link rel="preload" href="/benisarookie/assets/js/1.5739cfb0.js" as="script"><link rel="preload" href="/benisarookie/assets/js/34.421a448e.js" as="script"><link rel="prefetch" href="/benisarookie/assets/js/10.8a7f92a8.js"><link rel="prefetch" href="/benisarookie/assets/js/11.3e761738.js"><link rel="prefetch" href="/benisarookie/assets/js/12.3a8e52cd.js"><link rel="prefetch" href="/benisarookie/assets/js/13.8696a8fa.js"><link rel="prefetch" href="/benisarookie/assets/js/14.6f479bb1.js"><link rel="prefetch" href="/benisarookie/assets/js/15.33db6b39.js"><link rel="prefetch" href="/benisarookie/assets/js/16.3689a3a5.js"><link rel="prefetch" href="/benisarookie/assets/js/17.ef4d8cc7.js"><link rel="prefetch" href="/benisarookie/assets/js/18.3256f17f.js"><link rel="prefetch" href="/benisarookie/assets/js/19.a45744ea.js"><link rel="prefetch" href="/benisarookie/assets/js/20.c22d9498.js"><link rel="prefetch" href="/benisarookie/assets/js/21.388c94d1.js"><link rel="prefetch" href="/benisarookie/assets/js/22.bf2e3a8b.js"><link rel="prefetch" href="/benisarookie/assets/js/23.0fe15a35.js"><link rel="prefetch" href="/benisarookie/assets/js/24.b0c9d674.js"><link rel="prefetch" href="/benisarookie/assets/js/25.9a694497.js"><link rel="prefetch" href="/benisarookie/assets/js/26.8874d7da.js"><link rel="prefetch" href="/benisarookie/assets/js/27.eb1c7656.js"><link rel="prefetch" href="/benisarookie/assets/js/28.962f4b7f.js"><link rel="prefetch" href="/benisarookie/assets/js/29.6cfebcf0.js"><link rel="prefetch" href="/benisarookie/assets/js/3.c33b3aaa.js"><link rel="prefetch" href="/benisarookie/assets/js/30.35ee7ab1.js"><link rel="prefetch" href="/benisarookie/assets/js/31.9952d7ff.js"><link rel="prefetch" href="/benisarookie/assets/js/32.f611215a.js"><link rel="prefetch" href="/benisarookie/assets/js/33.dc6c8922.js"><link rel="prefetch" href="/benisarookie/assets/js/4.45665f8a.js"><link rel="prefetch" href="/benisarookie/assets/js/5.b31b942f.js"><link rel="prefetch" href="/benisarookie/assets/js/6.4910e764.js"><link rel="prefetch" href="/benisarookie/assets/js/7.c5640ac7.js"><link rel="prefetch" href="/benisarookie/assets/js/vendors~docsearch.5e19b665.js">
    <link rel="stylesheet" href="/benisarookie/assets/css/0.styles.5cdbf686.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/benisarookie/" class="home-link router-link-active"><!----> <span class="site-name">笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/benisarookie/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/benisarookie/面试/面试.html" class="nav-link">
  面试
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="测试" class="dropdown-title"><span class="title">测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="测试" class="mobile-dropdown-title"><span class="title">测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/benisarookie/测试目录一/测试.html" class="nav-link">
  测试111
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  生活习惯
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/benisarookie/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/benisarookie/面试/面试.html" class="nav-link">
  面试
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="测试" class="dropdown-title"><span class="title">测试</span> <span class="arrow down"></span></button> <button type="button" aria-label="测试" class="mobile-dropdown-title"><span class="title">测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/benisarookie/测试目录一/测试.html" class="nav-link">
  测试111
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  生活习惯
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>idea快捷键</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/benisarookie/面试/面试.html" class="active sidebar-link">面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#索引失效" class="sidebar-link">索引失效</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#spring的常见注释" class="sidebar-link">spring的常见注释</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#springboot的注释" class="sidebar-link">springBoot的注释</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#springmvc常见的注释" class="sidebar-link">springMVC常见的注释</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#sql优化" class="sidebar-link">sql优化</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#数据库优化" class="sidebar-link">数据库优化</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#reentrantlock-和synchronized区别" class="sidebar-link">ReentrantLock 和synchronized区别</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#lock和synchronized的区别" class="sidebar-link">Lock和synchronized的区别</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#java的锁" class="sidebar-link">java的锁</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#redis缓存穿透" class="sidebar-link">redis缓存穿透</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#redis缓存雪崩" class="sidebar-link">redis缓存雪崩</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#redis缓存击穿" class="sidebar-link">redis缓存击穿</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#redis数据删除策略" class="sidebar-link">redis数据删除策略</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#分布式锁" class="sidebar-link">分布式锁</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#什么情况下事务会失效" class="sidebar-link">什么情况下事务会失效</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#mysql中innodb和myisam存储引擎的区别" class="sidebar-link">mysql中InnoDB和myISAM存储引擎的区别</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#hashmap" class="sidebar-link">hashMap</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#简述是nginx" class="sidebar-link">简述是nginx？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#nginx负载均衡的5种策略" class="sidebar-link">nginx负载均衡的5种策略</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#事务的传播" class="sidebar-link">事务的传播</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#aop" class="sidebar-link">AOP</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#postmapping和-getmapping的区别" class="sidebar-link">@PostMapping和@GetMapping的区别</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#redis持久化" class="sidebar-link">redis持久化</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#cap定理" class="sidebar-link">CAP定理</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#分布式事务" class="sidebar-link">分布式事务</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#线程池应该设置多少核心线程数" class="sidebar-link">线程池应该设置多少核心线程数</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#nacos隔离机制" class="sidebar-link">nacos隔离机制</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#循环依赖" class="sidebar-link">循环依赖</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#cpu飙升100-如何排查" class="sidebar-link">CPU飙升100%如何排查</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#事务隔离级别" class="sidebar-link">事务隔离级别</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#线程池参数和启动流程" class="sidebar-link">线程池参数和启动流程</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#sql执行很慢怎么处理" class="sidebar-link">SQL执行很慢怎么处理</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#了解过索引吗" class="sidebar-link">了解过索引吗？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#索引的底层数据结构了解过吗" class="sidebar-link">索引的底层数据结构了解过吗？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#索引创建的原则有哪些" class="sidebar-link">索引创建的原则有哪些？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#什么是聚集索引什么二级索引" class="sidebar-link">什么是聚集索引什么二级索引？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#知道什么是回表吗" class="sidebar-link">知道什么是回表吗？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#谈一谈sql的优化经验" class="sidebar-link">谈一谈sql的优化经验</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#事务的特性可以讲一下吗" class="sidebar-link">事务的特性可以讲一下吗？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#undo-log和redo-log的区别" class="sidebar-link">undo log和redo log的区别</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#springcloud5大组件有哪些" class="sidebar-link">SpringCloud5大组件有哪些？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#rabbitmq如何保证消息不丢失" class="sidebar-link">RabbitMq如何保证消息不丢失</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#rabbitmq消息的重复消费问题如何解决" class="sidebar-link">RabbitMq消息的重复消费问题如何解决？</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#rabbitmq死信交换机" class="sidebar-link">RabbitMq死信交换机</a></li><li class="sidebar-sub-header"><a href="/benisarookie/面试/面试.html#消息堆积怎么处理" class="sidebar-link">消息堆积怎么处理？</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JAVA</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>RabbitMq</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis/MP</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="面试"><a href="#面试" class="header-anchor">#</a> 面试</h1> <h2 id="索引失效"><a href="#索引失效" class="header-anchor">#</a> 索引失效</h2> <p><strong>1.最佳左前缀</strong></p> <p>（最左优先，在检索数据时从联合索引的最左边开始匹配），例如索引(a,b,c)，只有查询   	(a),(a,b),(a,b,c)会走索引，而(b),(b,c),(c)都不会走索引。</p> <p><strong>2.计算、函数会导致索引失效</strong></p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_name <span class="token keyword">ON</span> student<span class="token punctuation">(</span>NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#1.函数导致索引失效，没有走索引</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> SQL_NO_CACHE <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> <span class="token keyword">LEFT</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>
<span class="token comment">#索引优化成like，走索引</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> SQL_NO_CACHE <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> student<span class="token punctuation">.</span>name <span class="token operator">LIKE</span> <span class="token string">'abc%'</span><span class="token punctuation">;</span>
 
<span class="token comment">#2.计算导致索引失效</span>
<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_sno <span class="token keyword">ON</span> student<span class="token punctuation">(</span>stuno<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> SQL_NO_CACHE id<span class="token punctuation">,</span> stuno<span class="token punctuation">,</span> NAME <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> stuno<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">900001</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>3.类型转换会导致索引失效</strong></p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_name <span class="token keyword">ON</span> student<span class="token punctuation">(</span>NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">#1.手动类型转换，通过调用函数，导致索引失效</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> stuno<span class="token punctuation">,</span> name <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> name<span class="token operator">=</span>CAST<span class="token punctuation">(</span><span class="token number">123</span> <span class="token keyword">as</span> <span class="token keyword">CHAR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">#2.自动类型转换导致索引失效。name字段类型是varchar，你赋值成数字它会默认转成字符串导致索引失败</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> SQL_NO_CACHE <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment"># 索引优化成目标字符串，走索引</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> SQL_NO_CACHE <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>4.范围条件右边的列索引失效</strong></p> <p>例如（a,b,c）联合索引，查询条件a,b,c，如果b使用了范围查询，那么b右边的c索引失效。</p> <p>**解决办法：**新建联合索引（a,c,b）或（c,a,b），把需要范围查询的字段放在最后。</p> <p>范围包括：(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between。</p> <p><strong>5.“不等于”导致索引失效</strong></p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> idx_age_name <span class="token keyword">ON</span> student<span class="token punctuation">(</span>age<span class="token punctuation">,</span> NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#查所有字段，并且使用“不等于”，索引失效</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> age <span class="token operator">&lt;&gt;</span> <span class="token number">20</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>6.没覆盖索引时，is not null、not like导致索引失效</strong></p> <p><strong>解决方案：</strong></p> <ul><li><strong>设计数据库的时候就将字段设置为 NOT NULL 约束</strong></li> <li>将 INT 类型的字段，默认值设置为0。</li> <li>将字符类型的默认值设置为空字符串('')。</li></ul> <p><strong>7.左模糊查询导致索引失效</strong></p> <p><strong>8.“OR”前后存在非索引列，导致索引失效</strong></p> <p>OR前后的两个条件中的列都是索引时，查询中才使用索引</p> <p><strong>9.不同字符集导致索引失败，建议utf8mb4</strong></p> <p>**10.隐式类型转换，**会导致索引失效，例如 id字段类型是varchar，我们 where id = 1，这样就会触发隐式类型转换</p> <h2 id="spring的常见注释"><a href="#spring的常见注释" class="header-anchor">#</a> spring的常见注释</h2> <table><thead><tr><th style="text-align:center;">注释</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">@Component、@Controller、@Service、@Repository</td> <td style="text-align:center;">使用在类上用于实例化bean</td></tr> <tr><td style="text-align:center;">@Autowire</td> <td style="text-align:center;">使用在字段上用于根据类型依赖注入</td></tr> <tr><td style="text-align:center;">@Qualifier</td> <td style="text-align:center;">结合@Autowire一起使用用于根据名称进行依赖注入</td></tr> <tr><td style="text-align:center;">@Scope</td> <td style="text-align:center;">标注Bean的作用范围</td></tr> <tr><td style="text-align:center;">@Configuration</td> <td style="text-align:center;">指定当前类是一个Spring配置类，当创建容器时会从该类上加载注释</td></tr> <tr><td style="text-align:center;">@ComponentScan</td> <td style="text-align:center;">用于指定Spring在初始化容器时要扫描的包</td></tr> <tr><td style="text-align:center;">@Bean</td> <td style="text-align:center;">使用在方法上，标注将该方法返回值存储到spring容器中</td></tr> <tr><td style="text-align:center;">@Import</td> <td style="text-align:center;">使用@Import导入的类会被Spring加载到ioc容器中</td></tr> <tr><td style="text-align:center;">@Aspect、@Before、@After、@Around、@Pointcut</td> <td style="text-align:center;">用于切面编程（AOP）</td></tr></tbody></table> <ol><li><strong>@Configuration</strong>：这个注解用于声明一个类作为配置类，通常用于定义Bean的配置信息。它替代了传统的XML配置方式，提供了更灵活和类型安全的配置选项。</li> <li><strong>@Bean</strong>：这个注解用于在配置类中定义一个Bean，它告诉Spring这个方法将返回一个对象，该对象应被注册为Spring应用上下文中的一个Bean。</li> <li><strong>@Autowired</strong>：这个注解用于自动装配Bean。它可以帮助Spring自动注入依赖，减少手动配置的工作量。</li></ol> <h2 id="springboot的注释"><a href="#springboot的注释" class="header-anchor">#</a> springBoot的注释</h2> <ol><li><strong>@SpringBootApplication</strong>：这是一个复合注解，包含了@Configuration、@EnableAutoConfiguration和@ComponentScan三个注解的功能。它用于声明一个类为Spring Boot应用的主类，是程序的入口点。</li> <li><strong>@EnableAutoConfiguration</strong>：这个注解告诉Spring Boot根据添加的jar依赖自动配置项目。例如，如果项目中包含了Spring MVC的依赖，Spring Boot会自动配置Spring MVC相关的组件。</li> <li><strong>@ComponentScan</strong>：这个注解用于告诉Spring在哪些包下进行组件扫描，以便找到并注册Bean。它可以帮助Spring找到并管理项目中的所有组件。</li></ol> <h2 id="springmvc常见的注释"><a href="#springmvc常见的注释" class="header-anchor">#</a> springMVC常见的注释</h2> <ol><li><strong>@PathVariable</strong>：这个注解用于从URL中提取变量值，并将其绑定到控制器方法的参数上。它常用于RESTful API的路由参数绑定。</li> <li><strong>@RequestBody</strong>：这个注解用于将HTTP请求体中的数据绑定到控制器方法的参数上。它常用于接收JSON格式的数据。</li> <li><strong>@ResponseBody</strong>：这个注解用于将控制器方法的返回值转换为HTTP响应的主体。它使得控制器方法返回的对象能够直接作为HTTP响应的内容发送给客户端。</li> <li><strong>@RestController</strong>：这个注解是@Controller和@ResponseBody的组合，用于声明一个类为RESTful Web服务的控制器。它使得该类中的方法返回的对象能够直接作为JSON格式的数据发送给客户端。</li></ol> <h2 id="sql优化"><a href="#sql优化" class="header-anchor">#</a> sql优化</h2> <p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引（或联合索引）。</p> <p>2.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p> <p>3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p> <p>4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</p> <p>5.左模糊查询也将导致全表扫描：</p> <p>6.in 和 not in 也要慎用，否则会导致全表扫描</p> <p>7.如果在 where 子句中使用@参数，也会导致全表扫描。</p> <p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p> <p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描</p> <p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p> <p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p> <p>12.不要写一些没有意义的查询</p> <p>13.很多时候用 exists 代替 in 是一个好的选择</p> <p>14.并不是所有索引对查询都有效</p> <p>15.索引并不是越多越好</p> <p>16.应尽可能的避免更新 clustered 索引数据列</p> <p>17.尽量使用数字型字段</p> <p>18.尽可能的使用 varchar/nvarchar 代替 char/nchar</p> <p>19.任何地方都不要使用 <code>select * from t</code>，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p> <p>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p> <p>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。</p> <p>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效</p> <p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度</p> <p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p> <p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p> <p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p> <p>27.与临时表一样，游标并不是不可使用</p> <p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。</p> <p>29.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p> <p>30.尽量避免大事务操作，提高系统并发能力。</p> <h2 id="数据库优化"><a href="#数据库优化" class="header-anchor">#</a> 数据库优化</h2> <p>1.<strong>是否请求了不需要的数据</strong></p> <p>2.<strong>是否扫描了额外的记录</strong></p> <p>3.<strong>一个复杂查询OR多个简单查询</strong></p> <p>4.<strong>切分查询</strong></p> <p>5.<strong>分解关联查询</strong></p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> teacher t
<span class="token keyword">join</span> student s <span class="token keyword">on</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> s<span class="token punctuation">.</span>t_id
<span class="token keyword">join</span> class c <span class="token keyword">on</span> t<span class="token punctuation">.</span>id <span class="token operator">=</span> c<span class="token punctuation">.</span>t_id
<span class="token keyword">where</span> t<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Li'</span><span class="token punctuation">;</span>
<span class="token comment">-- 拆分后</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> teacher t <span class="token keyword">where</span> t<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Li'</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student s <span class="token keyword">where</span> s<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> class c <span class="token keyword">where</span> c<span class="token punctuation">.</span>id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">65</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="reentrantlock-和synchronized区别"><a href="#reentrantlock-和synchronized区别" class="header-anchor">#</a> ReentrantLock 和synchronized区别</h2> <p>1.<strong>灵活性</strong></p> <ul><li><code>ReentrantLock</code> 提供了更多的灵活性，例如可以指定尝试获取锁的最大等待时间和是否可中断等。</li></ul> <p>2.<strong>中断性</strong>:</p> <ul><li><code>ReentrantLock</code> 允许线程在等待锁的过程中被中断（通过 <code>lockInterruptibly()</code> 方法），而 <code>synchronized</code> 不支持。</li></ul> <p>3.<strong>公平性</strong></p> <ul><li><code>ReentrantLock</code> 允许你选择是否要公平地分配锁（<code>true</code> 或 <code>false</code> 作为构造参数），这意味着如果设置为公平锁，锁将按照请求锁的顺序来分配。</li></ul> <p>4.<strong>锁的实现</strong></p> <ul><li><code>ReentrantLock</code> 是显式锁（Explicit Lock），需要程序员手动获取和释放。</li> <li><code>synchronized</code> 是隐式锁，它由编译器和运行时来保证正确的获取和释放。</li></ul> <p>5.<strong>使用范围</strong></p> <ul><li><code>ReentrantLock</code> 可以用于方法之外的场景，如同步代码块或某个特定的代码段。</li> <li><code>synchronized</code> 主要用于同步方法或同步代码块。</li></ul> <h2 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="header-anchor">#</a> Lock和synchronized的区别</h2> <p><strong><code>Lock</code>：</strong> 是Java中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。</p> <ul><li>1.Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别</li> <li>2.Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言实现。</li> <li>3.synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</li> <li>4.Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</li> <li>5.通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li> <li>6.Lock 可以通过实现读写锁提高多个线程进行读操作的效率。</li></ul> <p><strong>synchronized的优势：</strong></p> <ul><li>足够清晰简单，只需要基础的同步功能时，用synchronized。</li> <li>Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即使出现异常，锁也能被自动释放。</li> <li>使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。</li></ul> <h2 id="java的锁"><a href="#java的锁" class="header-anchor">#</a> java的锁</h2> <p>1.<strong>乐观锁</strong></p> <p><strong>是一种乐观思想</strong>，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）。</p> <p>2.<strong>悲观锁</strong></p> <p><strong>是一种悲观思想</strong>，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。</p> <p>3.<strong>读写锁</strong></p> <p>通过<code>ReentrantReadWriteLock</code>类来实现。为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的。</p> <p><strong>读锁：</strong> 允许多个线程获取读锁，同时访问同一个资源。</p> <p><strong>写锁：</strong> 只允许一个线程获取写锁，不允许同时访问同一个资源。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
* 创建一个读写锁
* 它是一个读写融为一体的锁，在使用的时候，需要转换
*/</span>
<span class="token keyword">private</span> <span class="token class-name">ReentrantReadWriteLock</span> rwLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取读锁</span>
rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 释放读锁</span>
rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建一个写锁</span>
rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 写锁 释放</span>
rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>4.<strong>公平锁</strong></p> <p>多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。</p> <p>5.<strong>非公平锁</strong></p> <p>线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁。</p> <p><strong>优点：</strong> 非公平锁的性能高于公平锁。</p> <p><strong>缺点：</strong> 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）</p> <p>**Java中的非公平锁：**synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。</p> <p>6.<strong>共享锁</strong></p> <p>可以有多个线程获取读锁，以共享的方式持有锁。和乐观锁、读写锁同义。</p> <p><strong>Java中用到的共享锁：</strong> <code>ReentrantReadWriteLock</code>。</p> <p>7.<strong>独占锁</strong></p> <p>只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。</p> <p><strong>Java中用到的独占锁：</strong> synchronized，ReentrantLock</p> <p>8.<strong>重量级锁</strong></p> <p><code>synchronized</code>是通过对象内部的一个叫做监视器锁（<code>monitor</code>）来实现的，监视器锁本身依赖底层的操作系统的 <code>Mutex Lock</code>来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 <code>Mutex Lock</code>来实现的锁称为重量级锁。为了优化<code>synchonized</code>，引入了<code>轻量级锁</code>，<code>偏向锁</code>。</p> <p><strong>Java中的重量级锁：</strong> synchronized</p> <h2 id="redis缓存穿透"><a href="#redis缓存穿透" class="header-anchor">#</a> redis缓存穿透</h2> <p>**描述：**指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果 key 不存在或者 key 已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。但是这种方法存在一个问题，比如我传一个用户 id 为 - 1，这个用户 id 在缓存里面是肯定不存在的，所以会去数据库里面查询，如果有搞事情的人，大批量请求并传用户 id 为 - 1，那就和没用 redis 一样，导致数据库压力过大而崩溃。</p> <p><strong>解决方法：</strong></p> <p>**方法一：**在接口层增加校验，不合法的参数直接返回。不相信任务调用方，根据自己提供的 API 接口规范来，作为被调用方，要考虑可能任何的参数传值。</p> <p>**方法二：**在缓存查不到，DB 中也没有的情况，可以将对应的 key 的 value 写为 null，或者其他特殊值写入缓存，同时将过期失效时间设置短一点，以免影响正常情况。这样是可以防止反复用同一个 ID 来暴力攻击。</p> <p>**方法三：**正常用户是不会这样暴力功击，只有是恶意者才会这样做，可以在网关 NG 作一个配置项，为每一个 IP 设置访问阈值。</p> <p>**方法四：**高级用户布隆过滤器（Bloom Filter), 这个也能很好地防止缓存穿透。原理就是利用高效的数据结构和算法快速判断出你这个 Key 是否在 DB 中存在，不存在你 return 就好了，存在你就去查了 DB 刷新 KV 再 return。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>https://www.bilibili.com/video/BV1zK4y1h7pA/?spm_id_from=333.880.my_history.page.click&amp;vd_source=87ca7d166405133710d8da17bacab1ea
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="redis缓存雪崩"><a href="#redis缓存雪崩" class="header-anchor">#</a> redis缓存雪崩</h2> <p>**在同一个时间，缓存大批量的失效，然后所有请求都打到 DB 数据库，导致 DB 数据库直接扛不住崩了。**比如，电商首页缓存，如果首页的 key 全部都在某一时刻失效，刚好在那一时刻有秒杀活动，那这样的话就所有的请求都被打到了 DB。并发大的情况下 DB 必然扛不住，没有其他降级之类的方案的话，DBA 也只能重启 DB，但是这样又会被新的流量搞挂。</p> <h4 id="解决方法-缓存雪崩"><a href="#解决方法-缓存雪崩" class="header-anchor">#</a> <strong>解决方法–缓存雪崩</strong></h4> <p>批量往 redis 存数据的时候，把每个 key 的失效时间加上个随机数，比如 1-5 分钟随机，这样的话就能保证数据不会在同一个时间大面积失效。</p> <h2 id="redis缓存击穿"><a href="#redis缓存击穿" class="header-anchor">#</a> redis缓存击穿</h2> <p>缓存击穿跟缓存雪崩有些类似，雪崩是大面积缓存失效，导致数据库崩溃，而缓存击穿是一个 key 是热点，不停地扛住大并发请求，全都集中访问此 key, 而当此 key 过期瞬间，持续的大并发就击穿缓存，全都打在 DB 上。就又引发雪崩的问题。</p> <p><strong>解决方法–缓存击穿</strong>
**方法一：**把这个热点 key 设置为永久有效。</p> <p>**方法二：**使用互斥锁，这是比较常用的方法，简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去查询数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行查询数据库的操作并回设缓存；否则，就重试整个 get 缓存的方法。</p> <h2 id="redis数据删除策略"><a href="#redis数据删除策略" class="header-anchor">#</a> redis数据删除策略</h2> <p><strong>1.惰性删除</strong>：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删除它返回key</p> <p>​	<strong>优点</strong>：对cpu有好，只会在使用该key时才会进行过期检查对于很多用不到的key不用 浪费时间进行过期检查</p> <p>​	<strong>缺点</strong>：对内存不友好，如果一个key过期，但是一直没有被使用，那么该key就会一直存在在内存中，内存永远不会被释放</p> <p><strong>2.定期删除</strong>：每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。
<strong>定期清理有两种模式</strong> <strong>SLOW模式</strong>是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf的hz 选项来调整这个次数
<strong>FAST模式</strong>执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms
<strong>优点</strong>:可以通过限制删除操作执行的时减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期数据占用的内存。
<strong>缺点</strong>:难以确定删除操作执行的时长和删除频率
<strong>Redis的过期删除策略</strong>:惰性删除+定期删除两种策略进行配合使用</p> <h2 id="分布式锁"><a href="#分布式锁" class="header-anchor">#</a> 分布式锁</h2> <p><strong>1.setNX</strong>(不推荐)</p> <p>SETNX命令的工作过程是去set一个不存在的key，多个线程去设置同一个key只会有一个线程设置成功，设置成功的的线程拿到锁。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Boolean</span> flag <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>vaue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>**缺点：**1.首先是不原子性的（要想进行原子性操作得用lua脚本）2.不支持可重入</p> <p><strong>2.Redisson分布式锁</strong></p> <p>Redisson 是封装了 lua 脚本，保证获取、判断、加锁操作的原子性，一个客户端要加锁，它首先会根据<a href="https://so.csdn.net/so/search?q=hash&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">hash<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>节点选择一台机器，这里注意仅仅只是选择一台机器，紧接着就会发送一段封装好的 lua 脚本到 redis 上。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span>
<span class="token class-name">RedissionClient</span> redissionClient<span class="token punctuation">;</span>

<span class="token class-name">RLock</span> lock <span class="token operator">=</span> redissionClient<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">&quot;coursequerylock:&quot;</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//释放锁</span>
lock<span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token comment">//执行方法</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
    <span class="token comment">//释放锁</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>锁续期机制</strong></p> <p>Redisson 提供了一个续期机制，只要客户端 1 一旦加锁成功，就会启动一个 Watch Dog (看门狗)</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>注意：

1、参数 leaseTime 必须是 -1 才会开启 Watch Dog 机制，也就是如果你想开启 Watch Dog 机制必须使用默认的加锁时间为 30s。如果你自定义释放时间，超过这个时间锁就会自定释放，并不会延长

2、这里有个问题，如果服务宕机了，Watch Dog 机制后台定时任务线程也就没有了，此时就不会延长 key 的过期时间，到了 30s 之后就会自动过期，其他线程就可以获取到锁
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>总结</strong></p> <p>1、Redisson 通过 Watch Dog 机制很好的解决了锁的续期问题</p> <p>2、Redisson 基于 Redis 性能很高，适合对性能要求高的场景</p> <p>3、Redisson 实现分布式可重入锁，比原生的 SET mylock userId NX PX milliseconds + lua 实现的效果更好些，虽然基本原理都一样，但是它帮我们封装了内部的执行细节(官方封装更严谨)</p> <p>4、在等待申请锁资源占用上也做了一些优化，减少了无效的锁申请，提升了资源的利用率</p> <p>5、Redisson 的获取锁默认是非公平的(随机抢锁)，可以使用 getFairLock() 获取公平锁对象（线程将以其请求的时间顺序获取锁），如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//公平锁，保证 Redisson 客户端线程将以其请求的顺序获得锁</span>
<span class="token class-name">RLock</span> fairLock <span class="token operator">=</span> redissonClient<span class="token punctuation">.</span><span class="token function">getFairLock</span><span class="token punctuation">(</span><span class="token string">&quot;fairLock&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="什么情况下事务会失效"><a href="#什么情况下事务会失效" class="header-anchor">#</a> 什么情况下事务会失效</h2> <p>1.在方法中捕获异常没有抛出</p> <p>2.@Transaction标记的方法不是public</p> <p>3.抛出的异常与事务指定异常不一致，默认的异常是RuntimeExecption</p> <p>4.内部调用而不是代理对象调用</p> <p>5.数据不支持事务。比如mysql 的 MYISAM</p> <p>6.spring传播行为导致事务失效</p> <h2 id="mysql中innodb和myisam存储引擎的区别"><a href="#mysql中innodb和myisam存储引擎的区别" class="header-anchor">#</a> mysql中InnoDB和myISAM存储引擎的区别</h2> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">InnoDB</th> <th style="text-align:center;">myISAM</th></tr></thead> <tbody><tr><td style="text-align:center;">事务处理</td> <td style="text-align:center;">√</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">表锁及行锁</td> <td style="text-align:center;">√</td> <td style="text-align:center;">仅支持表锁</td></tr> <tr><td style="text-align:center;">外键约束</td> <td style="text-align:center;">√</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">索引结构</td> <td style="text-align:center;">B+</td> <td style="text-align:center;">B</td></tr> <tr><td style="text-align:center;">崩溃恢复</td> <td style="text-align:center;">√</td> <td style="text-align:center;"></td></tr></tbody></table> <h2 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> hashMap</h2> <p>hashmap是通过键值对key-value的形式存放，并允许有null和null值，key的null值只能有一个，他是无序的，针对单线程设计的是非线程安全的</p> <p>**put（）方法：**调用hashcode计算出key的hash值并通过哈希表函数将之转换为下标，之后通过equal进行比较，如果相等更新value值，不相等直接插入。在put中如果插入的个数超过了数组长度×负载因子，就会将数组扩容为之前的两倍，链表长度长度超过默认为8的阈值就会转换为红黑树</p> <p>**get（）方法：**通过调用hashCode计算出哈希值，根据下标去遍历链表，再进行equals比较，之后再把数据返回给用户</p> <h2 id="简述是nginx"><a href="#简述是nginx" class="header-anchor">#</a> 简述是nginx？</h2> <p>Nginx是一个 轻量级/高性能的反向代理Web服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP协议。他实现非常高效的<strong>反向代理</strong>、<strong>负载平衡</strong>，他可以处理2-3万并发连接数，官方监测能支持5万并发，现在中国使用nginx网站用户有很多，例如:新浪、网易、腾讯等</p> <h2 id="nginx负载均衡的5种策略"><a href="#nginx负载均衡的5种策略" class="header-anchor">#</a> nginx负载均衡的5种策略</h2> <ol><li><code>round_robin</code>：轮询（默认）。</li> <li><code>least_conn</code>：最少连接。</li> <li><code>ip_hash</code>：根据客户端IP地址。</li> <li><code>random</code>：随机。</li> <li><code>random two</code>：随机两次尝试，然后回到轮询。</li></ol> <h2 id="事务的传播"><a href="#事务的传播" class="header-anchor">#</a> 事务的传播</h2> <p>事务的传播行为，主要分为三种类型，分别是：<strong>支持当前事务</strong>、<strong>不支持当前事务</strong>、<strong>嵌套事务</strong></p> <p><strong>1 支持当前事务</strong></p> <p><strong>REQUIRED</strong>：默认的事务传播级别，表示如果当前方法已在事务内，该方法就在当前事务中执行，否则，开启一个新的事务并在其上下文中执行。（默认的事务传播行为，保证多个嵌套的事务方法在同一个事务内执行，并且同时提交，或者出现异常时，同时回滚。）</p> <p><strong>SUPPORTED</strong>：当前方法在事务内，则在其上下文中执行该方法，否则，开启一个新的事务。（当外层方法A存在事务，方法B加入到当前事务中，以事务的方式执行。）</p> <p><strong>MANDATORY</strong>：必须在事务中执行，否则，将抛出异常。（必须在事务中执行）</p> <p><strong>2 不支持当前事务</strong></p> <p><strong>REQUIRES_NEW</strong>：无论当前是否有事务上下文，都会开启一个事务 。如果已经有一个事务在执行 ，则正在执行的事务将被挂起 ，新开启的事务会被执行。（每次都开启一 个新的事务。）</p> <p>事务之间相互独立，互不干扰。</p> <p><strong>NOT_SUPPORTED</strong>：不支持事务，如果当前存在事务上下文，则挂起当前事务，然后以非事务的方式执行。（不支持事务。）</p> <p><strong>NEVER</strong>：不能在事务中执行，如果当前存在事务上下文，则抛出异常。（不支持事务）</p> <p><strong>3 嵌套事务</strong></p> <p><strong>NESTED</strong>：嵌套事务，如果当前已存在一个事务的上下文中，则在嵌套事务中执行，如果抛异常，则回滚嵌套事务，而不影响其他事务的操作。</p> <ul><li>如果外层方法A不存在事务，内层方法B的规则与REQUIRED 一致。</li> <li>如果外层方法A存在事务，内层方法B做为外层方法A事务的子事务执行，两个方法是一起提交，但子事务是独立回滚。
内层方法B抛出异常，则会回滚方法B的所有操作，但不影响外层事务方法A。（方法A需要try-catch子事务，避免异常传递到父层事务）
外层方法A回滚，则内层方法B也会回滚。</li> <li>该传播性的特点是可以保存状态点，当回滚时，只会回滚到某一个状态点，保证了子事务之间的独立性，避免嵌套事务的全局回滚。</li></ul> <h2 id="aop"><a href="#aop" class="header-anchor">#</a> AOP</h2> <p>AOP（面向切面编程）是一种编程范式，用于将横切关注点与核心业务逻辑分离开来。</p> <p><strong>AOP由以下几个部分组成：</strong></p> <p>1.连接点（JoinPoint）:程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等</p> <p>2、切入点（Pointcut）:匹配连接点的式子（一个切入点可以只描述一个具体方法，也可以匹配多个方法）</p> <p>3、通知（Advice）：在切入点处执行的操作，也就是共性的功能</p> <p>4、通知类：定义通知的类，（包含多个不同的通知）</p> <p>5、切面（Aspect）：描述通知与切入点的对应关系。（使用@Aspect注解标识）</p> <p>6、目标对象：原始功能去掉共性功能对应的类产生的对象，这种对象无法直接完成最终工作的，也是我们要添加共性功能的对象。</p> <p>7、代理实现：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现（一般我们自定义一个接口，将接口加入到目标对象（方法）中，使切入点对映接口）</p> <p><strong>导入依赖</strong></p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code><span class="token comment">&lt;!--springboot集成Aop--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>定义一个切面类</strong>，在切面类中实现我们的AOP增强操作。加入@Aspect注解，定义为切面类，并在切面类中，实现通知和切入点的实现，并绑定它们之间的关系。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Aspect</span>   <span class="token comment">//切面类</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>切入点表达式</strong></p> <ul><li><code>execution</code>：匹配方法的执行。</li> <li><code>within</code>：匹配在特定类或包中的所有方法。</li> <li><code>args</code>：匹配具有特定参数类型的方法。</li> <li><code>target</code>：匹配特定目标对象的方法。</li> <li><code>this</code>和<code>bean</code>：匹配当前代理对象或特定Spring bean的方法。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code>	<span class="token comment">/**
     * aop：切面，切入点，通知
     * 切面：泛指交叉的业务逻辑。比如日志记录，事务管理就是一个切面
     * 切入点：切入的地方
     * 通知：对代码增强的
     * 切入点
     */</span>
<span class="token comment">//       (&quot;execution(任意返回值 com.sky.mapper下的任意类的任意方法（任意参数）&amp;&amp;方法上有AutoFill的注释的）“）</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">autoFillPointCut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token comment">/**
     * 前置通知，在通知中进行公共字段的赋值
     */</span>
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">&quot;autoFillPointCut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">autoFill</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//前置实现代码</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

	<span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">&quot;autoFillPointCut()&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterWay</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//后置实现代码</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
 	<span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;autoFillPointCut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">aroundWay</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">//前置执行</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">// 执行原方法</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//后置执行</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p><strong>aop通知方式</strong></p> <ul><li><code>@Before</code>：在方法执行之前执行。</li> <li><code>@After</code>：在方法执行之后执行，无论方法是否成功。</li> <li><code>@AfterReturning</code>：在方法成功返回之后执行。</li> <li><code>@AfterThrowing</code>：在方法抛出异常之后执行。</li> <li><code>@Around</code>：在方法执行前后都执行，可以完全控制方法的执行过程。</li></ul> <p><strong>统一赋值的操作示例：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>	<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
	<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
	<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">AutoFill</span> <span class="token punctuation">{</span>
    	<span class="token comment">//数据库操作类型：UPDATE INSERT</span>
    	<span class="token class-name">OperationType</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">&quot;autoFillPointCut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">autoFill</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;开始进行公共字段填充。。。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        System.out.println(&quot;------------------------------&quot;);</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;joinPoint&quot;</span><span class="token operator">+</span>joinPoint<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//获取到当前被拦截方法上的数据库操作类型</span>
        <span class="token class-name">MethodSignature</span> signature <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">MethodSignature</span><span class="token punctuation">)</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取方法签名对象</span>
        <span class="token class-name">AutoFill</span> annotation <span class="token operator">=</span> signature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">AutoFill</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取方法上的额注解对象</span>
        <span class="token class-name">OperationType</span> operationType <span class="token operator">=</span> annotation<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取数据库操作类型 UPDATE INSERT</span>
        <span class="token comment">//获取到当前被拦截的方法的参数--实体对象</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> args<span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//判断数据中的对象是否存在</span>


        <span class="token class-name">Object</span> entity <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//默认取第一个参数</span>

        <span class="token comment">//准备赋值的数据</span>
        <span class="token class-name">LocalDateTime</span> now <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Long</span> currentId <span class="token operator">=</span> <span class="token class-name">BaseContext</span><span class="token punctuation">.</span><span class="token function">getCurrentId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//根据当前不同的操作类型，为对应的属性通过反射来赋值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>operationType <span class="token operator">==</span> <span class="token class-name">OperationType</span><span class="token punctuation">.</span><span class="token constant">INSERT</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//为4个公共字段赋值</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">//反射获取类方法</span>
                <span class="token class-name">Method</span> setCreateTime <span class="token operator">=</span> entity<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">AutoFillConstant</span><span class="token punctuation">.</span><span class="token constant">SET_CREATE_TIME</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Method</span> setCreateUser <span class="token operator">=</span> entity<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">AutoFillConstant</span><span class="token punctuation">.</span><span class="token constant">SET_CREATE_USER</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Method</span> setUpdateTime <span class="token operator">=</span> entity<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">AutoFillConstant</span><span class="token punctuation">.</span><span class="token constant">SET_UPDATE_TIME</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Method</span> setUpdateUser <span class="token operator">=</span> entity<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">AutoFillConstant</span><span class="token punctuation">.</span><span class="token constant">SET_UPDATE_USER</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">//数据赋值</span>
                setCreateTime<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>entity<span class="token punctuation">,</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
                setCreateUser<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>entity<span class="token punctuation">,</span>currentId<span class="token punctuation">)</span><span class="token punctuation">;</span>
                setUpdateTime<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>entity<span class="token punctuation">,</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
                setUpdateUser<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>entity<span class="token punctuation">,</span>currentId<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>


        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>operationType <span class="token operator">==</span> <span class="token class-name">OperationType</span><span class="token punctuation">.</span><span class="token constant">UPDATE</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//为2个公共字段赋值</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">//反射获取类方法</span>
                <span class="token class-name">Method</span> setUpdateTime <span class="token operator">=</span> entity<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">AutoFillConstant</span><span class="token punctuation">.</span><span class="token constant">SET_UPDATE_TIME</span><span class="token punctuation">,</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Method</span> setUpdateUser <span class="token operator">=</span> entity<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token class-name">AutoFillConstant</span><span class="token punctuation">.</span><span class="token constant">SET_UPDATE_USER</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">//数据赋值</span>
                setUpdateTime<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>entity<span class="token punctuation">,</span>now<span class="token punctuation">)</span><span class="token punctuation">;</span>
                setUpdateUser<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>entity<span class="token punctuation">,</span>currentId<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br></div></div><h2 id="postmapping和-getmapping的区别"><a href="#postmapping和-getmapping的区别" class="header-anchor">#</a> @PostMapping和@GetMapping的区别</h2> <p>1.参数传递方式：@GetMapping通常是从URL中获取参数，@PostMapping是从请求体中获取参数</p> <p>2.安全性：post请求将数据放在请求体中，get是将请求数据放在url中，所以post比get更安全，尽量不要用get请求处理敏感数据</p> <p>3.RESTful设计中，getMapping一般是查询数据请求，postMapping用作创建或者更新数据</p> <p>4.参数限制：get请求的参数没有长度限制，但是url长度有限制，所以get请求的参数太长后端可能获取不全所有的参数</p> <h2 id="redis持久化"><a href="#redis持久化" class="header-anchor">#</a> redis持久化</h2> <p>将redis数据存储到系统磁盘上，防止服务进行重启之后导致数据丢失</p> <p>**持久化方式：**RDB和AOF</p> <p><strong>快照方式RDB（redis DateBase）：</strong> 将某一时刻的redis的内存数据，以二进制的方式写入磁盘，速度快，会丢失数据</p> <p><strong>文件追加方式AOF（Append only）</strong></p> <h2 id="cap定理"><a href="#cap定理" class="header-anchor">#</a> CAP定理</h2> <ul><li>Consistency（一致性）</li> <li>Availability（可用性）</li> <li>Partition tolerance（分区容错性）</li></ul> <h2 id="分布式事务"><a href="#分布式事务" class="header-anchor">#</a> 分布式事务</h2> <h4 id="seata的xa模式-cp模式-强一致性"><a href="#seata的xa模式-cp模式-强一致性" class="header-anchor">#</a> <strong>seata的XA模式</strong>（cp模式（强一致性））</h4> <p><strong>RM一阶段的工作：</strong></p> <p>1.注册分支事务到TC</p> <p>2.执行分支业务sql但不提交</p> <p>3.报告执行状态到TC</p> <p><strong>TC二阶段的工作：</strong></p> <p>TC检测各个分支事务执行状态</p> <p>a.如果成功，通知所有RM提交事务</p> <p>b.如果失败，通知所有RM回滚事务</p> <p><strong>RM二阶段的工作</strong></p> <p>接收TC指令，提交或者回滚事务</p> <h2 id="线程池应该设置多少核心线程数"><a href="#线程池应该设置多少核心线程数" class="header-anchor">#</a> 线程池应该设置多少核心线程数</h2> <p><strong>cpu密集型</strong>：cpu核心数+1</p> <p><strong>IO密集型</strong>：cpu核心数*2</p> <p><strong>混合型任务</strong>：</p> <ul><li>需要根据实际测试调整</li> <li>可以先设置为CPU核心数的2-3倍，然后根据监控调整</li></ul> <h2 id="nacos隔离机制"><a href="#nacos隔离机制" class="header-anchor">#</a> nacos隔离机制</h2> <p>nacos通过namespace实现环境隔离</p> <h2 id="循环依赖"><a href="#循环依赖" class="header-anchor">#</a> 循环依赖</h2> <p><img src="image20250401111523205.png" alt="image-20250401111523205"></p> <p>两个或者两个以上的bean互相持有对方，最终行程闭环</p> <p><strong>解决方式</strong>：三级缓存</p> <p>​	一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</p> <p>​	二级缓存：缓存早期的bean对象（生命周期还没有走完）</p> <p>​	三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象</p> <h2 id="cpu飙升100-如何排查"><a href="#cpu飙升100-如何排查" class="header-anchor">#</a> CPU飙升100%如何排查</h2> <p><strong>解决方法论</strong>：</p> <p>​	1.查看占用cpu最高的TOP N 线程</p> <p>​	2.查看TOP N线程堆栈信息</p> <p>​	3.根据代码针对性解决问题</p> <p><strong>使用jstack解决CPU 100%问题</strong>：</p> <p>​	1.查看占用cpu最高的TOP N 线程---top -Hp 29400</p> <p>​	2.查看TOP N线程堆栈信息---jstack -l 29440</p> <p>​	3.根据代码针对性解决问题</p> <p><strong>使用arthas解决CPU 100%问题</strong>：</p> <p>​	1.查看占用cpu最高的TOP N 线程 --- dashboard</p> <p>​	2.查看TOP N线程堆栈信息 --- thread -n 3</p> <p>​	3.根据代码针对性解决问题</p> <h2 id="事务隔离级别"><a href="#事务隔离级别" class="header-anchor">#</a> 事务隔离级别</h2> <table><thead><tr><th style="text-align:center;">隔离级别</th> <th style="text-align:center;">脏读</th> <th style="text-align:center;">不可重复读</th> <th style="text-align:center;">幻读</th></tr></thead> <tbody><tr><td style="text-align:center;">Read uncommitted 未提交读</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td></tr> <tr><td style="text-align:center;">Read commited 读已提交</td> <td style="text-align:center;">×</td> <td style="text-align:center;">√</td> <td style="text-align:center;">√</td></tr> <tr><td style="text-align:center;">Repeatable Read(默认) 可重复读</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td> <td style="text-align:center;">√</td></tr> <tr><td style="text-align:center;">Serializable 串行化</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td> <td style="text-align:center;">×</td></tr></tbody></table> <h2 id="线程池参数和启动流程"><a href="#线程池参数和启动流程" class="header-anchor">#</a> 线程池参数和启动流程</h2> <p><strong>线程池(ThreadPoolExecutor)的主要配置参数包括：</strong></p> <ol><li><strong>corePoolSize</strong> (核心线程数)
<ul><li>线程池中保持的最小线程数，即使这些线程处于空闲状态也不会被回收</li> <li>默认情况下，核心线程会在初始时被创建，也可以通过prestartAllCoreThreads()方法提前创建</li></ul></li> <li><strong>maximumPoolSize</strong> (最大线程数)
<ul><li>线程池允许创建的最大线程数量</li> <li>当工作队列满时，线程池会创建新线程直到达到此数量</li></ul></li> <li><strong>keepAliveTime</strong> (线程空闲时间)
<ul><li>当线程数超过核心线程数时，多余的空闲线程在终止前等待新任务的最长时间</li> <li>单位通常为TimeUnit.SECONDS、TimeUnit.MILLISECONDS等</li></ul></li> <li><strong>unit</strong> (时间单位)
<ul><li>keepAliveTime的时间单位</li></ul></li> <li><strong>workQueue</strong> (工作队列)
<ul><li>用于保存等待执行的任务的阻塞队列</li> <li>常用实现：LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue</li></ul></li> <li><strong>threadFactory</strong> (线程工厂)
<ul><li>用于创建新线程的工厂</li> <li>可以自定义线程名称、优先级等</li></ul></li> <li><strong>handler</strong> (拒绝策略)
<ul><li>当线程池和工作队列都满时，用于处理新提交的任务的策略</li> <li>内置策略：
<ul><li>AbortPolicy(默认)：抛出RejectedExecutionException</li> <li>CallerRunsPolicy：由提交任务的线程自己执行</li> <li>DiscardPolicy：直接丢弃任务</li> <li>DiscardOldestPolicy：丢弃队列中最老的任务并重试</li></ul></li></ul></li></ol> <p><strong>线程池启动流程</strong></p> <ol><li><p><strong>初始化线程池</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
    corePoolSize<span class="token punctuation">,</span>
    maximumPoolSize<span class="token punctuation">,</span>
    keepAliveTime<span class="token punctuation">,</span>
    unit<span class="token punctuation">,</span>
    workQueue<span class="token punctuation">,</span>
    threadFactory<span class="token punctuation">,</span>
    handler
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p><strong>提交任务</strong></p> <ul><li>通过execute()方法提交Runnable任务</li> <li>通过submit()方法提交Callable任务(可以获取返回值)</li></ul></li> <li><p><strong>任务处理流程</strong></p> <ol><li>当新任务提交时，如果当前运行的线程数小于corePoolSize，则创建新线程执行任务</li> <li>如果运行的线程数等于或大于corePoolSize，则将任务加入workQueue</li> <li>如果队列已满且运行的线程数小于maximumPoolSize，则创建新线程执行任务</li> <li>如果队列已满且运行的线程数等于maximumPoolSize，则根据拒绝策略处理任务</li></ol></li> <li><p><strong>线程回收</strong></p> <ul><li>当线程池中的线程数超过corePoolSize时，空闲时间超过keepAliveTime的线程会被终止</li> <li>核心线程默认不会被回收，除非设置allowCoreThreadTimeOut(true)</li></ul></li> <li><p><strong>线程池关闭</strong></p> <ul><li>shutdown(): 平缓关闭，不再接受新任务，但会处理完已提交的任务</li> <li>shutdownNow(): 立即关闭，尝试中断正在执行的任务，返回未处理的任务列表</li></ul></li></ol> <h2 id="sql执行很慢怎么处理"><a href="#sql执行很慢怎么处理" class="header-anchor">#</a> SQL执行很慢怎么处理</h2> <p><strong>用explain查看sql执行情况，其中涉及重要的参数有</strong></p> <table><thead><tr><th style="text-align:center;">字段</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">possible_key</td> <td style="text-align:center;">当前sql可能会使用到的索引</td></tr> <tr><td style="text-align:center;">key</td> <td style="text-align:center;">当前sql命中的索引</td></tr> <tr><td style="text-align:center;">key_len</td> <td style="text-align:center;">索引占用的大小</td></tr> <tr><td style="text-align:center;">Extra</td> <td style="text-align:center;">额外的优化建议</td></tr> <tr><td style="text-align:center;">type</td> <td style="text-align:center;">sql的连接类型（在index或者all便需要优化）</td></tr></tbody></table> <p>Extra可能会出现以下两种情况：</p> <table><thead><tr><th style="text-align:center;">Extra</th> <th style="text-align:center;">含义</th></tr></thead> <tbody><tr><td style="text-align:center;">Using where;Using index</td> <td style="text-align:center;">查询使用了索引，需要的数据都在索引列中能着找到，不需要回表查询数据</td></tr> <tr><td style="text-align:center;">using index condition</td> <td style="text-align:center;">查询使用了索引吗，但是需要回表查询数据</td></tr></tbody></table> <p>若回表查询可以尝试添加索引来修复</p> <h2 id="了解过索引吗"><a href="#了解过索引吗" class="header-anchor">#</a> 了解过索引吗？</h2> <ul><li>索引是帮助sql搞笑获取数据的数据结构（有序）</li> <li>提高数据检索的效率，降低数据库的io成本（不需要全表扫描）</li> <li>通过索引列对数据进行排序，降低数据排序的成本，降低了cpu的消耗</li></ul> <h2 id="索引的底层数据结构了解过吗"><a href="#索引的底层数据结构了解过吗" class="header-anchor">#</a> 索引的底层数据结构了解过吗？</h2> <p><strong>底层采用B+数的数据结构来存储索引</strong></p> <ul><li>阶数更多，路径更短</li> <li>磁盘读写代价B+树是很低的，并且非叶子节点只存储指针，叶子阶段存储数据</li> <li>B+树便于扫库和区间查询，叶子节点是一个双向链表</li></ul> <h2 id="索引创建的原则有哪些"><a href="#索引创建的原则有哪些" class="header-anchor">#</a> 索引创建的原则有哪些？</h2> <ol><li>针对数据量大，且查询频繁的表创建索引（单表数据超过10w）</li> <li>针对常作为查询条件（where），排序（order by）和分组（group by）操作的字段建立索引</li> <li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li> <li>控制索引数量</li> <li>如果索引不能存储null值，在创建表时用notnull约束</li></ol> <h2 id="什么是聚集索引什么二级索引"><a href="#什么是聚集索引什么二级索引" class="header-anchor">#</a> 什么是聚集索引什么二级索引？</h2> <table><thead><tr><th style="text-align:center;">分类</th> <th style="text-align:center;">含义</th> <th style="text-align:center;">特点</th></tr></thead> <tbody><tr><td style="text-align:center;">聚集索引</td> <td style="text-align:center;">将数据存储与索引放到一起，索引结构的叶子节点保证了行数据</td> <td style="text-align:center;">必须有，而且只能有一个</td></tr> <tr><td style="text-align:center;">二级索引</td> <td style="text-align:center;">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td> <td style="text-align:center;">可以存在多个</td></tr></tbody></table> <p><strong>聚集索引选取规则：</strong></p> <ul><li>如果存在主键，主键索引就是聚集索引</li> <li>如果不存在主键，将使用第一个唯一索引作为聚集索引</li> <li>如果表没有主键，或没有合适的唯一索引，则innoDB会生成一个rowid作为隐藏的聚集索引</li></ul> <h2 id="知道什么是回表吗"><a href="#知道什么是回表吗" class="header-anchor">#</a> 知道什么是回表吗？</h2> <p>通过二级索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表</p> <h2 id="谈一谈sql的优化经验"><a href="#谈一谈sql的优化经验" class="header-anchor">#</a> 谈一谈sql的优化经验</h2> <ul><li><strong>表的设计优化</strong></li></ul> <ol><li>比如设置合适的数据（tinyint（1字节） int（4字节） bigint（8字节）），要根据实际情况选择</li> <li>比如设置合适的字符串类型（char和varchar），char定长效率高，varchar可变长度，效率低</li></ol> <ul><li><strong>SQL语句优化</strong></li></ul> <ol><li>避免直接使用select*</li> <li>sql语句中要避免造成索引失效的写法</li> <li>尽量用union all 代替 union    后者会多一次过滤，效率低</li> <li>避免where子句中进行表达式操作</li> <li>join优化能用innerjoin 就不用 leftjoin rightjoin，如果必须使用一定要以小表为驱动</li></ol> <ul><li><strong>主从复制，读写分离</strong></li></ul> <h2 id="事务的特性可以讲一下吗"><a href="#事务的特性可以讲一下吗" class="header-anchor">#</a> 事务的特性可以讲一下吗？</h2> <p>ACID：分别是原子性、一致性、隔离性、持久性；举个例子a向b转账100，转账成功，a扣100，b会增加100，原子操作体现要么成功要么都失败，在转账的过程中，数据要一致a扣了100，b必须增加100，在转账过程中，隔离体检在啊向b转账，不能受其他事物影响，持久性体现在事务提交之后要把数据落盘。</p> <h2 id="undo-log和redo-log的区别"><a href="#undo-log和redo-log的区别" class="header-anchor">#</a> undo log和redo log的区别</h2> <p>redo log日志记录是数据页的物理变化，服务宕机可用来同步数据，而undolog不同，他主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如删除一条数据的时候，就会在undolog日志文件中新增一条delete语句，如果发生回滚就会进行逆操作。</p> <p>redolog 保证了事务的持久性，undolog 保证了事务的原子性和一致性。</p> <h2 id="springcloud5大组件有哪些"><a href="#springcloud5大组件有哪些" class="header-anchor">#</a> SpringCloud5大组件有哪些？</h2> <ul><li>注册中心：nacos</li> <li>负载均衡：Ribbon</li> <li>远程调用：Feign</li> <li>服务熔断：Hystrix</li> <li>网关：gateway</li></ul> <h2 id="rabbitmq如何保证消息不丢失"><a href="#rabbitmq如何保证消息不丢失" class="header-anchor">#</a> RabbitMq如何保证消息不丢失</h2> <p><img src="image-20250427214540222.png" alt="image-20250427214540222"></p> <p><img src="image-20250427214820899.png" alt="image-20250427214820899"></p> <p><img src="image-20250427215034785.png" alt="image-20250427215034785"></p> <p><img src="image-20250427215207023.png" alt="image-20250427215207023"></p> <h2 id="rabbitmq消息的重复消费问题如何解决"><a href="#rabbitmq消息的重复消费问题如何解决" class="header-anchor">#</a> RabbitMq消息的重复消费问题如何解决？</h2> <p>1.每条消息设置一个唯一的标识id，检索该id是否存在</p> <p>2.幂等方案：分布式锁，数据库锁（悲观锁或者乐观锁）</p> <h2 id="rabbitmq死信交换机"><a href="#rabbitmq死信交换机" class="header-anchor">#</a> RabbitMq死信交换机</h2> <p><img src="image-20250427220409531.png" alt="image-20250427220409531"></p> <h2 id="消息堆积怎么处理"><a href="#消息堆积怎么处理" class="header-anchor">#</a> 消息堆积怎么处理？</h2> <p><img src="image-20250427221147147.png" alt="image-20250427221147147"></p> <p>1.增加更多消费者，提高消费速度</p> <p>2.在消费者内开启线程池加快消息处理速度</p> <p>3.扩大队列容积，提高堆积上限</p> <p>4.RabbitMq存在惰性队列（将接收到的消息存在磁盘中，消费的时候在从磁盘中获取消息）</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">lastUpdated:</span> <span class="time">4/27/2025, 10:38:27 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/benisarookie/idea快捷键/idea快捷键.html" class="prev">
        idea快捷键位
      </a></span> <span class="next"><a href="/benisarookie/JAVA基础/init.html">
        java基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/benisarookie/assets/js/app.b911dc94.js" defer></script><script src="/benisarookie/assets/js/2.d4767806.js" defer></script><script src="/benisarookie/assets/js/1.5739cfb0.js" defer></script><script src="/benisarookie/assets/js/34.421a448e.js" defer></script>
  </body>
</html>
