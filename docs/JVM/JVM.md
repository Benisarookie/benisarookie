# JVM

## 1.JVM是什么？

jvm全程是java Virtual Machine，译名java虚拟机，是一个运算在计算机上的程序，他的职责是运行java字节码文件。

## 2.jvm的三大核心功能是什么？

jvm包含内存管理、解释执行虚拟机指令、即时编译三大功能。

## 3.jvm的功能

1.解释和运行：对字节码文件中的指令，实时的解释成机器码，让计算机运行

2.内存管理：

​		a.自动为对象、方法等分配内存

​		b.自动的垃圾回收机制，回收不在使用的对象

3.即时编译：对热点代码进行优化，提升执行效率

## 4.jvm的组成

类加载子系统、运行时数据区、执行引擎、本地接口

![](D:\software\benisarookie\docs\.vuepress\dist\assets\img\jvm组成.jpg)

## 5.运行时数据区

运行时数据区指的是jvm所管理的内存区域，其中分成两大类：线程共享-**方法区、栈**  线程不共享- **本地方法栈、虚拟机栈、程序计数器**

直接内存主要是NIO使用，由操作系统直接管理，不属于jvm内存。

![](C:\Users\Ben\AppData\Roaming\Typora\typora-user-images\image-20240629185913167.png)

**a.程序计数器：**也叫pc寄存器，每个线程会通过程序计数器记录当前要执行的字节码指令的地址

**作用：** 

**1**、程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。

**2**、在多线程执行情况下，**Java**虚拟机需要通过程序计数器记录**CPU**切换前解释执行到那一句指令并继续解释运行

**b.栈-java虚拟机栈**

Java虚拟机栈采用栈的数据结构来管理方法调用中的基本数据，先进后出 ， **每一个方法的调用**使用一个**栈帧**来保存。每个线程都会包含一个自己的虚拟机栈，它的生命周期和线程相同。

**c.栈帧**

主要包含三部分内容：

1、局部变量表，在方法执行过程中存放所有的局部变量。

2、操作数栈，虚拟机在执行指令过程中用来存放临时数据的一块区域。

3、帧数据，主要包含动态链接、方法出口、异常表等内容

**d.堆**

1.一般Java程序中堆内存是空间最大的一块内存区域。**创建出来的对象**都存在于**堆**上。

2.栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。

3.堆是垃圾回收最主要的部分，堆结构更详细的划分与垃圾回收器有关

**e、方法区**

方法区是Java虚拟机规范中提出来的一个虚拟机概念，在**HotSpot**不同版本中会用永久代或者元空间来实现。方法区主要存放的是基础信息，包含：

**1**、每一个加载的类的元信息（基础信息）。

**2**、运行时常量池，保存了字节码文件中的常量池内容，避免常量内容重复创建减少内存开销。

**3**、字符串常量池，存储字符串的常量

**f本地方法栈**

本地方法栈

1.Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧。

2.在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内

存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来

**什么是运行时数据区？**

运行时数据区指的是JVM所管理的内存区域，其中分成两大类：

线程共享 – **方法区、堆**

方法区：存放每一个加载的类的元信息、运行时常量池、字符串常量池。

堆：存放创建出来的对象。

线程不共享 – **本地方法栈、虚拟机栈、程序计数器**

本地方法栈和虚拟机栈都存放了线程中执行方法时需要使用的基础数据。

程序计数器存放了当前线程执行的字节码指令在内存中的地址。

直接内存主要是NIO使用，由操作系统直接管理，不属于JVM内存

## 哪些区域会出现内存溢出，会有什么现象？

在**Java**虚拟机中，只有**程序计数器**不会出现内存溢出的情况，因为每个线程的程序计数器只保存一个固定长度的地址

**堆内存溢出：**

堆内存溢出指的是在堆上分配的对象空间超过了堆的最大大小，从而导致的内存溢出。堆的最大大小使用**-Xmx**参数进行设置，如**-Xmx10m**代表最大堆内存大小为**10m**。溢出之后会抛出**OutOfMemoryError**，并提示是**Java heap Space**导致的：

**栈内存溢出：**

栈内存溢出指的是所有栈帧空间的占用内存超过了最大值，最大值使用**-Xss**进行设置，比如**-Xss256k**代表所有栈帧占用内存大小加起来不能超过**256k**。溢出之后会抛出**StackOverflowError**：

**方法区内存溢出：**

方法区内存溢出指的是方法区中存放的内容比如类的元信息超过了方法区内存的最大值，**JDK7**及之前版本方法区使用**永久代（-XX:MaxPermSize=值）**来实现，**JDK8**及之后使用**元空间（-XX:MaxMetaspaceSize=值）**来实现。

**直接内存溢出：**

直接内存溢出指的是申请的直接内存空间大小超过了最大值，使用 **-XX:MaxDirectMemorySize=**值 设置最大值。溢出之后会抛出**OutOfMemoryError**：

## 有几种类加载器？

1.启动类加载器（Bootstrap ClassLoader）加载核心类

2.扩展类加载器（Extension ClassLoader）加载扩展类

3.应用程序类加载器（Application ClassLoader）加载应用classpath中的类

4.自定义类加载器，重写findClass方法。

JDK9及之后扩展类加载器（Extension ClassLoader）变成了平台类加载器（Platform 

ClassLoader）

## 什么是双亲委派机制？

双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会**向上交给父类加载器查找是否加载过，再由顶向下进行加载。**

**双亲委派机制的作用：**保证类加载的安全性，避免重复加载

**打破双亲委派机制的方法：**实现自定义类加载器，重写defineClass方法，将双亲委

派机制的代码去除。